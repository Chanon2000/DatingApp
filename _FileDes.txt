[Startup.cs]
    0. [ทำการ inject IConfiguration]
        แบบนี้คือ สร้าง instance ชื่อ Configuration เป็น IConfiguration โดยไม่ต้อง inject ลง contrtutor ก่อน (ไม่นิยม)
            // public IConfiguration Configuration { get; } 

        แบบ inject ลง construtor
            private readonly IConfiguration _config; 
                - ใส่ _ เพื่อเพิ่มความแตกต่างกับตัวแปรอื่น 
                - เปลี่ยน configuration เป็น _config เพื่อให้ง่ายในการเขียน
            public Startup(IConfiguration config) // configuration ถูก inject ลง Startup (construtor ของ Startup) 
            - IConfiguration ถูก inject ลง Startup ทำให้เราเข้าถึง IConfiguration ได้โดยตัวแปร _config
            {
                _config = config; # เมื่อเติม _ ทำให้ไม่ต้องเติม this ( this.config => _config ) 
            }

    1. ConfigureServices =>  เพื่อ add พวก class หรือ method ที่จะใช้ในหลายๆที่ลงตรงนี้
        - คือถ้าคุณอยากจะสร้าง service หรือ class ที่สามารถใช้ใน พื้นที่อื่นได้ เราต้อง add เข้ามาในนี้
        services.AddCors();
        services.AddControllers();

    2. Configure =>  ใช้ในการตั้งค่า HTTP request pipeline (คล้ายกับ middleware ที่ req หรือ res จะผ่านก่อน)
        - ใส่ให้เป็นลำดับสำคัญมาก
        app.UseRouting()
        app.UseCors()

        endpoints.MapControllers(); => คือเก็บ endpoint แล้วมา map กับ controller ตรงนี้
                                    => ซึ่งตรงนี้จะดูใน controller ว่า controller ไหนที่ตรงกับ endpoint
    เช่น ต้องการเพิ่ม CORS 
        ไปใส่ services.AddCors(); ที่ ConfigureServices 
        จากนั้นก็ไปสั่งใช้งานที่ Configure => app.UseCors(x => x.AllowAnyHeader().AllowAnyMethod().WithOrigins("https://localhost:4200"));

    3. เขียนแยก Extension
        1. สร้าง folder "Extensions"
        2. สร้าง construtor
        3. cut service ใน นี้ ไปไว้ที่ extension
        4. return services
        5. เรียก applicationservice ที่ stratup

[UserController.cs]
    using Microsoft.AspNetCore.Mvc; // "Mvc" ซึ่ง API controller ที่เราเขียนอยู่ ก็คือ "c"
                                    // "v" จะมาจากข้างนอก (angular)

    1. [ApiController] // ApiController
    - [Route("api/[controller]")] // root // [controller] เรียกว่าเป็น placeholder แทนชื่อนำหน้าของ controllder class นี้

    2. public class UsersController : ControllerBase => ControllerBase

    3. สร้าง construtor
        private readonly DataContext _context;
        public UsersController(DataContext context) // inject DataContext เข้าไป
        {
            _context = context;
        }

    4. add endpoint
        [HttpGet]

    5. เปลี่ยน code เป็น async
        1. public ActionResult<IEnumerable<AppUser>> GetUsers() // แบบไม่ async
           เป็นเป็น async โดยการ
            1. เพิ่ม async
            2. หุ้ม type return ด้วย Task
        // แต่ไม่แก้เป็น async ก็จะไม่ค่อยเห็นความเปลี่ยนแปลงอะไรเนื่องจาก app เรามันเล็กอยู่แล้ว เลยไม่ดห็นว่าความรวดเร็วมันเพิ่มขึ้น
        2. public async Task<ActionResult<IEnumerable<AppUser>>> GetUsers() // แบบ async
            <IEnumerable<AppUser>> คือ type ของสิ่งที่จะ return
            อ่านว่า IEnumerable ของ AppUser
                // หรือเราจะใช้ List แทนก็ได้ <List<AppUser>> 
                // แต่เนื่องจากว่า List มันมีบริการ search , จัดการกับข้อมูลมากมายซึ่งในที่นี้เราแค่ต้องการ return ไปให้ client ดู จึงใช้ IEnumerable ดีกว่า
                // ทั้ง IEnumerable และ List เหมือนกันคือ return list ของ user ไปให้ client


        ใน ืmethod GetUsers()
        public async Task<ActionResult<IEnumerable<AppUser>>> GetUsers(){
            // V: แรก
            // var users = _context.Users.ToList(); //สร้าง ตัวแปรเก็บข้อมูล users
            // return users;

            // V:ลดcode
                // return _context.Users.ToList(); //สร้าง ตัวแปรเก็บข้อมูล users

            // V: asynchronous
                // นั้นคือจะทำให้ถ้ามีคน hit req นี้ มันการจะไปทำงาน thread นึง ในขณะเดียวกันมีอีกคน hit req นี้ มันก็จะสามารถส่งไปอีก thread นึงได้
                return await _context.Users.ToListAsync(); // เนื่องจาก ToList() ไม่ใช่ async method ดังนั้นจึงใช้versionที่เป็นasyncนั้นคือ ToListAsync()
                // return _context.Users.ToListAsync().Result; // ใช้ .Result แทน await
        }

        ใน method GetUser(id)
        // public ActionResult<AppUser> GetUser(int id) // แบบไม่ async
        public async Task<ActionResult<AppUser>> GetUser(int id){
            // V: แรก
            // var user = _context.Users.Find(id); // Find() หา entity โดยรับ primary key มา
            // return user;

            // V:ลดcode
                // return _context.Users.Find(id); // Find() หา entity โดยรับ primary key มา

            // V: asynchronous
                return await _context.Users.FindAsync(id);
        }

        [Asynchronous]
            - จิตนาการว่าเรามีการ query ที่ซับซ้อน เช่น ต้องนับ record จำนวน 5 ล้าน record ซึ่งพฤติกรรมนี้ต้องใช้เวลานานถ้าเรา block thread นี้ก็ไม่ใช่เรื่องดี
            - ใน modern Web servers จะเป็น multithread เช่น Apache Web server อาจมี 100 threads ที่ใช้งานได้
            - เรามี 100 thead เพื่อใช้งาน ทำไมต้องให้มันรอจนกว่า data จะกลับมาหล่ะ
            - ด้วยการแก้ปัญหานั้นคือทำให้ code เราเป็น Asynchronous ไปเลย

[Program.cs]
    => ทุก app .net ต้องมี Program.cs ซึ่งมี class ที่มี main method // จะทำงานตรงนี้เป็นที่แรก
    
    CreateDefaultBuilder คือสิ่งสำคัญเพราะทำหลายอย่าง 
[Controller]
    BaseApiController => สร้างมารับ ControllerBase แทน
    |----> AccountController
    |----> UsersController

    // สิ่งที่ controllder ต้องทำคือ get data จาก database

[Interface]
    - interface คือ ตัวในการสื่อสารระหว่างมันกับ class อื่น ด้วยการใน class อื่น implements
    - ซึ่งมันจะเก็บแค่ signatures ของ class ที่มันเป็น interface ให้ แต่ไม่เก็บ logic
    - เติม I ที่ชื่อ เพื่อบอกว่ามันเป็น interface (เช่น ITokenService)

[appsettings.Development.json]
    - ที่ appsettings.Development.json => สามารถเก็บสิ่งที่เราไม่อยากให้คนอื่นเห็นได้
         เนื่องจาก connection string ไม่ได้เก็บ password 
             (ซึ่งก็ไม่ได้อำนวยกับเก็บความลับอยู่แล้ว)
             (แต่ sqlite connection string ไม่ใช่ความลับ)
             "ConnectionStrings" : { // เป็นพหูพจน์
                 "DefaultConnection" : "Data Source=datingapp.db"
             },
         นี้คือความงานของ SQLite ไม่ต้องใส่ ีuser,pass คือใส่แค่ ชื่อfileที่เราจะใช้เก็บ _.db
    - ใน appsettings.Dev "Warning" จะไม่ให้ข้อมูลเรามากเวลา developing => จะทำให้ในแถบ terminal เวลาสั่ง endpoint คุณจะเห็นข้อมูลเยอะขึ้น
    - เมื่อ run dotnet มันจะเข้าไปดูในส่วนของ "API" (ชื่อproject) ใน launchSettings เพื่อดูว่าต้องใช้อะไรบ้างในการเริ่มต้น run


[Entities]
    public int Id { get; set; } => public + type + name property => คือเป็บแบบสั้น

    เป็นแบบเต็ม
    // private int myVar; 
    // public int MyProperty
    // {
    //     get { return myVar; }
    //     set { myVar = value; }
    // }

    public เหมือนถึง property นี้สามารถ get ที่ class ไหนก็ได้

    protected คือ property นี้สามารถเข้าถึงได้จาก class นี้ และจากclass อื่นที่inherit class นี้

    private คือ สามารถ เข้าถึงแก้ไข จากclassนี้เท่านั้น


[Basic .NET]
    จาก DataContext
    namespace API.Data{  => นี้คือ namespace
                         => ระวังให้ดีเวลาย้ายfile คุณต้องเปลี่ยน namespace ด้วย
    }                    => ทุกครั้งที่จะใช้ class ใน namespace นี้คุณต้องอ้างถึง namespace
    
    public class DataContext : DbContext => อ้างถึง DbContext